// Generated by BUCKLESCRIPT VERSION 5.0.0, PLEASE EDIT WITH CARE

import * as $$Array from "../node_modules/bs-platform/lib/es6/array.js";
import * as Block from "../node_modules/bs-platform/lib/es6/block.js";
import * as Curry from "../node_modules/bs-platform/lib/es6/curry.js";
import * as Caml_array from "../node_modules/bs-platform/lib/es6/caml_array.js";
import * as Belt_Option from "../node_modules/bs-platform/lib/es6/belt_Option.js";
import * as Caml_option from "../node_modules/bs-platform/lib/es6/caml_option.js";
import * as Caml_exceptions from "../node_modules/bs-platform/lib/es6/caml_exceptions.js";
import * as CamlinternalLazy from "../node_modules/bs-platform/lib/es6/camlinternalLazy.js";
import * as Parser$ReasonSuperTinyCompiler from "./Parser.bs.js";
import * as Location$ReasonSuperTinyCompiler from "./Location.bs.js";
import * as ParseError$ReasonSuperTinyCompiler from "./ParseError.bs.js";

var CannotGet = Caml_exceptions.create("Combinators-ReasonSuperTinyCompiler.BasicCombinators.CannotGet");

var CannotGetError = Caml_exceptions.create("Combinators-ReasonSuperTinyCompiler.BasicCombinators.CannotGetError");

function get_exn(result) {
  if (result.tag) {
    throw [
          CannotGet,
          result[0]
        ];
  } else {
    return result[0][0];
  }
}

function get_error(result) {
  if (result.tag) {
    return result[0];
  } else {
    throw CannotGetError;
  }
}

function runParser(p, loc) {
  switch (p.tag | 0) {
    case 0 : 
        return Curry._1(p[1], loc);
    case 1 : 
        var ok = Curry._1(p[1], loc);
        if (ok.tag) {
          return /* Err */Block.__(1, [ParseError$ReasonSuperTinyCompiler.make(loc, p[0])]);
        } else {
          return ok;
        }
    case 2 : 
        return Curry._1(p[0], loc);
    
  }
}

function run(parser, input) {
  var match = runParser(parser, Location$ReasonSuperTinyCompiler.make(input, 0));
  if (match.tag) {
    return /* Err */Block.__(1, [match[0]]);
  } else {
    var match$1 = match[0];
    return /* Ok */Block.__(0, [/* tuple */[
                match$1[0],
                match$1[1]
              ]]);
  }
}

function string(str) {
  return /* Parser */Block.__(2, [(function (loc) {
                var arg = loc[/* input */0];
                var substr = (function (param) {
                      return arg.substr(param);
                    })(loc[/* offset */1]);
                if (substr.startsWith(str)) {
                  var charsConsumed = str.length;
                  return /* Ok */Block.__(0, [/* tuple */[
                              str,
                              Location$ReasonSuperTinyCompiler.inc(loc, charsConsumed)
                            ]]);
                } else {
                  return /* Err */Block.__(1, [ParseError$ReasonSuperTinyCompiler.make(loc, "Expected: " + str)]);
                }
              })]);
}

function orElse(p1, p2) {
  return /* Parser */Block.__(2, [(function (loc) {
                var ok = runParser(p1, loc);
                if (ok.tag) {
                  var tag = p2.tag | 0;
                  var ok$1 = runParser(tag === 250 ? p2[0] : (
                          tag === 246 ? CamlinternalLazy.force_lazy_block(p2) : p2
                        ), loc);
                  if (ok$1.tag) {
                    var error2 = ok$1[0];
                    var stack = error2[/* stack */0];
                    var otherFailures = $$Array.append(/* array */[ok[0]], error2[/* otherFailures */1]);
                    return /* Err */Block.__(1, [ParseError$ReasonSuperTinyCompiler.makeWith(stack, otherFailures)]);
                  } else {
                    return ok$1;
                  }
                } else {
                  return ok;
                }
              })]);
}

function flatMap(p, fn) {
  return /* Parser */Block.__(2, [(function (loc) {
                var match = runParser(p, loc);
                if (match.tag) {
                  return /* Err */Block.__(1, [match[0]]);
                } else {
                  var match$1 = match[0];
                  var match$2 = runParser(Curry._1(fn, match$1[0]), match$1[1]);
                  if (match$2.tag) {
                    return /* Err */Block.__(1, [match$2[0]]);
                  } else {
                    var match$3 = match$2[0];
                    return /* Ok */Block.__(0, [/* tuple */[
                                match$3[0],
                                match$3[1]
                              ]]);
                  }
                }
              })]);
}

function unit(a) {
  return /* Parser */Block.__(2, [(function (loc) {
                return /* Ok */Block.__(0, [/* tuple */[
                            a,
                            loc
                          ]]);
              })]);
}

function listOfN($$int, p) {
  return /* Parser */Block.__(2, [(function (loc) {
                var _i = $$int;
                var p$1 = p;
                var _loc = loc;
                var _acc = /* array */[];
                while(true) {
                  var acc = _acc;
                  var loc$1 = _loc;
                  var i = _i;
                  var match = runParser(p$1, loc$1);
                  if (match.tag) {
                    return /* Err */Block.__(1, [match[0]]);
                  } else {
                    var match$1 = match[0];
                    var loc$2 = match$1[1];
                    var newAcc = $$Array.append(acc, /* array */[match$1[0]]);
                    if (i <= 0) {
                      return /* Ok */Block.__(0, [/* tuple */[
                                  newAcc,
                                  loc$2
                                ]]);
                    } else {
                      _acc = newAcc;
                      _loc = loc$2;
                      _i = i - 1 | 0;
                      continue ;
                    }
                  }
                };
              })]);
}

function many(p) {
  return /* Parser */Block.__(2, [(function (loc) {
                var p$1 = p;
                var _loc = loc;
                var _acc = /* array */[];
                while(true) {
                  var acc = _acc;
                  var loc$1 = _loc;
                  var match = runParser(p$1, loc$1);
                  if (match.tag) {
                    return /* Ok */Block.__(0, [/* tuple */[
                                acc,
                                loc$1
                              ]]);
                  } else {
                    var match$1 = match[0];
                    _acc = $$Array.append(acc, /* array */[match$1[0]]);
                    _loc = match$1[1];
                    continue ;
                  }
                };
              })]);
}

function many1(p) {
  return /* Parser */Block.__(2, [(function (loc) {
                var err = runParser(many(p), loc);
                if (err.tag) {
                  return err;
                } else {
                  var match = err[0];
                  var loc$1 = match[1];
                  var v = match[0];
                  if (v.length === 0) {
                    return /* Err */Block.__(1, [ParseError$ReasonSuperTinyCompiler.make(loc$1, "Expected at least one repetition for parser")]);
                  } else {
                    return /* Ok */Block.__(0, [/* tuple */[
                                v,
                                loc$1
                              ]]);
                  }
                }
              })]);
}

function slice(p) {
  return /* Parser */Block.__(2, [(function (loc) {
                var match = runParser(p, loc);
                if (match.tag) {
                  return /* Err */Block.__(1, [match[0]]);
                } else {
                  var newLoc = match[0][1];
                  var charsConsumed = newLoc[/* offset */1] - loc[/* offset */1] | 0;
                  var arg = loc[/* input */0];
                  return /* Ok */Block.__(0, [/* tuple */[
                              (function (param) {
                                      return (function (param$1) {
                                          return arg.substr(param, param$1);
                                        });
                                    })(loc[/* offset */1])(charsConsumed),
                              newLoc
                            ]]);
                }
              })]);
}

function regex(regexpr) {
  return /* Parser */Block.__(2, [(function (loc) {
                var reg = new RegExp("^" + regexpr);
                var sstr = loc[/* input */0].substr(loc[/* offset */1]);
                if (reg.test(sstr)) {
                  var result = $$Array.map((function (x) {
                          return Belt_Option.getExn((x == null) ? undefined : Caml_option.some(x));
                        }), Belt_Option.getExn(Caml_option.null_to_opt(reg.exec(sstr))));
                  var charsConsumed = Caml_array.caml_array_get(result, 0).length;
                  var newLoc_000 = /* input */loc[/* input */0];
                  var newLoc_001 = /* offset */loc[/* offset */1] + charsConsumed | 0;
                  var newLoc = /* record */[
                    newLoc_000,
                    newLoc_001
                  ];
                  return /* Ok */Block.__(0, [/* tuple */[
                              result,
                              newLoc
                            ]]);
                } else {
                  return /* Err */Block.__(1, [ParseError$ReasonSuperTinyCompiler.make(loc, "Expected: " + regexpr)]);
                }
              })]);
}

function sepBy(sep, p) {
  return /* Parser */Block.__(2, [(function (loc) {
                var sep$1 = sep;
                var p$1 = p;
                var _loc = loc;
                var _acc = /* array */[];
                while(true) {
                  var acc = _acc;
                  var loc$1 = _loc;
                  var match = runParser(p$1, loc$1);
                  if (match.tag) {
                    return /* Ok */Block.__(0, [/* tuple */[
                                acc,
                                loc$1
                              ]]);
                  } else {
                    var match$1 = match[0];
                    var loc$2 = match$1[1];
                    var newAcc = $$Array.append(acc, /* array */[match$1[0]]);
                    var match$2 = runParser(sep$1, loc$2);
                    if (match$2.tag) {
                      return /* Ok */Block.__(0, [/* tuple */[
                                  newAcc,
                                  loc$2
                                ]]);
                    } else {
                      _acc = newAcc;
                      _loc = match$2[0][1];
                      continue ;
                    }
                  }
                };
              })]);
}

function label(m, p) {
  switch (p.tag | 0) {
    case 0 : 
        return p;
    case 1 : 
        return /* LabeledParser */Block.__(1, [
                  m,
                  p[1]
                ]);
    case 2 : 
        return /* LabeledParser */Block.__(1, [
                  m,
                  p[0]
                ]);
    
  }
}

function scope(m, p) {
  switch (p.tag | 0) {
    case 0 : 
        return /* ScopedParser */Block.__(0, [
                  $$Array.append(/* array */[m], p[0]),
                  p[1]
                ]);
    case 1 : 
        return /* ScopedParser */Block.__(0, [
                  /* array */[m],
                  p[1]
                ]);
    case 2 : 
        return /* ScopedParser */Block.__(0, [
                  /* array */[],
                  p[0]
                ]);
    
  }
}

function attempt(p) {
  return /* Parser */Block.__(2, [(function (loc) {
                var match = runParser(p, loc);
                if (match.tag) {
                  return /* Ok */Block.__(0, [/* tuple */[
                              undefined,
                              loc
                            ]]);
                } else {
                  var match$1 = match[0];
                  return /* Ok */Block.__(0, [/* tuple */[
                              Caml_option.some(match$1[0]),
                              match$1[1]
                            ]]);
                }
              })]);
}

function fail(error) {
  return /* Parser */Block.__(2, [(function (loc) {
                return /* Err */Block.__(1, [ParseError$ReasonSuperTinyCompiler.make(loc, error)]);
              })]);
}

var BasicCombinators = /* module */[
  /* run */run,
  /* get_exn */get_exn,
  /* get_error */get_error,
  /* string */string,
  /* orElse */orElse,
  /* flatMap */flatMap,
  /* unit */unit,
  /* listOfN */listOfN,
  /* many */many,
  /* many1 */many1,
  /* slice */slice,
  /* regex */regex,
  /* sepBy */sepBy,
  /* label */label,
  /* scope */scope,
  /* attempt */attempt,
  /* fail */fail
];

var DP = Parser$ReasonSuperTinyCompiler.DerivedParsers(BasicCombinators);

var Ops = Parser$ReasonSuperTinyCompiler.InfixOps(BasicCombinators);

var map = DP[0];

var map2 = DP[1];

var product = DP[2];

var $$char = DP[3];

var Derived_Parsers = Ops[0];

var $great$great$eq = Ops[1];

var $less$$great = Ops[2];

var $great$great = Ops[3];

var $less$pipe$great = Ops[4];

export {
  BasicCombinators ,
  DP ,
  Ops ,
  run ,
  get_exn ,
  get_error ,
  string ,
  orElse ,
  flatMap ,
  unit ,
  listOfN ,
  many ,
  many1 ,
  slice ,
  regex ,
  sepBy ,
  label ,
  scope ,
  attempt ,
  fail ,
  map ,
  map2 ,
  product ,
  $$char ,
  Derived_Parsers ,
  $great$great$eq ,
  $less$$great ,
  $great$great ,
  $less$pipe$great ,
  
}
/* DP Not a pure module */
