// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Util$ReasonSuperTinyCompiler = require("./Util.bs.js");

function DerivedParsers(PS) {
  var map = function (parser, fn) {
    return Curry._2(PS[/* flatMap */5], parser, (function (v) {
                  return Curry._1(PS[/* unit */6], Curry._1(fn, v));
                }));
  };
  var map2 = function (parser1, parser2, fn) {
    return Curry._2(PS[/* flatMap */5], parser1, (function (v1) {
                  var tag = parser2.tag | 0;
                  return map(tag === 250 ? parser2[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(parser2) : parser2
                              ), (function (v2) {
                                return Curry._2(fn, v1, v2);
                              }));
                }));
  };
  var product = function (parser1, parser2) {
    return map2(parser1, parser2, (function (v1, v2) {
                  return /* tuple */[
                          v1,
                          v2
                        ];
                }));
  };
  var $$char = function (c) {
    return map(Curry._1(PS[/* string */3], Util$ReasonSuperTinyCompiler.char_to_string(c)), (function (s) {
                  return Caml_string.get(s, 0);
                }));
  };
  return /* module */[
          /* map */map,
          /* map2 */map2,
          /* product */product,
          /* char */$$char
        ];
}

function InfixOps(PS) {
  var map = function (parser, fn) {
    return Curry._2(PS[/* flatMap */5], parser, (function (v) {
                  return Curry._1(PS[/* unit */6], Curry._1(fn, v));
                }));
  };
  var map2 = function (parser1, parser2, fn) {
    return Curry._2(PS[/* flatMap */5], parser1, (function (v1) {
                  var tag = parser2.tag | 0;
                  return map(tag === 250 ? parser2[0] : (
                                tag === 246 ? CamlinternalLazy.force_lazy_block(parser2) : parser2
                              ), (function (v2) {
                                return Curry._2(fn, v1, v2);
                              }));
                }));
  };
  var product = function (parser1, parser2) {
    return map2(parser1, parser2, (function (v1, v2) {
                  return /* tuple */[
                          v1,
                          v2
                        ];
                }));
  };
  var $$char = function (c) {
    return map(Curry._1(PS[/* string */3], Util$ReasonSuperTinyCompiler.char_to_string(c)), (function (s) {
                  return Caml_string.get(s, 0);
                }));
  };
  var Derived_Parsers = /* module */[
    /* map */map,
    /* map2 */map2,
    /* product */product,
    /* char */$$char
  ];
  var $great$great$eq = PS[/* flatMap */5];
  var $less$pipe$great = PS[/* orElse */4];
  return /* module */[
          /* Derived_Parsers */Derived_Parsers,
          /* >>= */$great$great$eq,
          /* <$> */map,
          /* >> */product,
          /* <|> */$less$pipe$great
        ];
}

exports.DerivedParsers = DerivedParsers;
exports.InfixOps = InfixOps;
/* No side effect */
