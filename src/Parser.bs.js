// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Util$ReasonSuperTinyCompiler = require("./Util.bs.js");
var Location$ReasonSuperTinyCompiler = require("./Location.bs.js");

function DerivedParsers(PS) {
  var map = function (parser, fn) {
    return Curry._2(PS[/* flatMap */2], parser, (function (v) {
                  return Curry._1(PS[/* unit */3], Curry._1(fn, v));
                }));
  };
  var map2 = function (parser1, parser2, fn) {
    return Curry._2(PS[/* flatMap */2], parser1, (function (v1) {
                  return map(parser2, (function (v2) {
                                return Curry._2(fn, v1, v2);
                              }));
                }));
  };
  var product = function (parser1, parser2) {
    return map2(parser1, parser2, (function (v1, v2) {
                  return /* tuple */[
                          v1,
                          v2
                        ];
                }));
  };
  var $$char = function (c) {
    return map(Curry._1(PS[/* string */0], Util$ReasonSuperTinyCompiler.char_to_string(c)), (function (s) {
                  return Caml_string.get(s, 0);
                }));
  };
  return /* module */[
          /* map */map,
          /* map2 */map2,
          /* product */product,
          /* char */$$char
        ];
}

function InfixOps(PS) {
  var map = function (parser, fn) {
    return Curry._2(PS[/* flatMap */2], parser, (function (v) {
                  return Curry._1(PS[/* unit */3], Curry._1(fn, v));
                }));
  };
  var map2 = function (parser1, parser2, fn) {
    return Curry._2(PS[/* flatMap */2], parser1, (function (v1) {
                  return map(parser2, (function (v2) {
                                return Curry._2(fn, v1, v2);
                              }));
                }));
  };
  var product = function (parser1, parser2) {
    return map2(parser1, parser2, (function (v1, v2) {
                  return /* tuple */[
                          v1,
                          v2
                        ];
                }));
  };
  var $$char = function (c) {
    return map(Curry._1(PS[/* string */0], Util$ReasonSuperTinyCompiler.char_to_string(c)), (function (s) {
                  return Caml_string.get(s, 0);
                }));
  };
  var DP = /* module */[
    /* map */map,
    /* map2 */map2,
    /* product */product,
    /* char */$$char
  ];
  var $great$great$eq = PS[/* flatMap */2];
  var $less$pipe$great = PS[/* orElse */1];
  return /* module */[
          /* DP */DP,
          /* >>= */$great$great$eq,
          /* <$> */map,
          /* >> */product,
          /* <|> */$less$pipe$great
        ];
}

function makeWith(stack, failures) {
  return /* record */[
          /* stack */stack,
          /* otherFailures */failures
        ];
}

function make(loc, string) {
  return /* record */[
          /* stack : :: */[
            /* tuple */[
              loc,
              string
            ],
            /* [] */0
          ],
          /* otherFailures : [] */0
        ];
}

function getStackTrace(error) {
  return List.fold_left((function (acc, param) {
                var loc = param[0];
                var line = Location$ReasonSuperTinyCompiler.line(loc);
                var column = Location$ReasonSuperTinyCompiler.col(loc);
                var finalMessage = "" + (String(param[1]) + (" at line " + (String(line) + (", column " + (String(column) + "")))));
                return acc.concat(/* array */[finalMessage]);
              }), /* array */[], error[/* stack */0]);
}

function getAllStackTrace(error) {
  var otherFailureStackTraces = $$Array.fold_left($$Array.append, /* array */[], $$Array.map(getStackTrace, $$Array.of_list(error[/* otherFailures */1])));
  return $$Array.append(getStackTrace(error), otherFailureStackTraces);
}

function toString(error) {
  return getAllStackTrace(error).join("\n");
}

var ParseError = /* module */[
  /* makeWith */makeWith,
  /* make */make,
  /* getStackTrace */getStackTrace,
  /* getAllStackTrace */getAllStackTrace,
  /* toString */toString
];

function runParser(p, loc) {
  return Curry._1(p[0], loc);
}

function run(parser, input) {
  return runParser(parser, Location$ReasonSuperTinyCompiler.make(input, 0));
}

var CannotGet = Caml_exceptions.create("Parser-ReasonSuperTinyCompiler.Parsers.CannotGet");

var CannotGetError = Caml_exceptions.create("Parser-ReasonSuperTinyCompiler.Parsers.CannotGetError");

function get_exn(result) {
  if (result.tag) {
    throw [
          CannotGet,
          result[0]
        ];
  } else {
    return result[0][0];
  }
}

function get_error(result) {
  if (result.tag) {
    return result[0];
  } else {
    throw CannotGetError;
  }
}

function string(str) {
  return /* Parser */[(function (loc) {
              var arg = loc[/* input */0];
              var substr = (function (param) {
                    return arg.substr(param);
                  })(loc[/* offset */1]);
              if (substr.startsWith(str)) {
                var charsConsumed = str.length;
                return /* Ok */Block.__(0, [/* tuple */[
                            str,
                            Location$ReasonSuperTinyCompiler.inc(loc, charsConsumed)
                          ]]);
              } else {
                return /* Err */Block.__(1, [make(loc, "Expected: " + str)]);
              }
            })];
}

function orElse(p1, p2) {
  return /* Parser */[(function (loc) {
              var ok = runParser(p1, loc);
              if (ok.tag) {
                var ok$1 = runParser(p2, loc);
                if (ok$1.tag) {
                  var error2 = ok$1[0];
                  var stack = error2[/* stack */0];
                  var otherFailures_000 = ok[0];
                  var otherFailures_001 = error2[/* otherFailures */1];
                  var otherFailures = /* :: */[
                    otherFailures_000,
                    otherFailures_001
                  ];
                  return /* Err */Block.__(1, [/* record */[
                              /* stack */stack,
                              /* otherFailures */otherFailures
                            ]]);
                } else {
                  return ok$1;
                }
              } else {
                return ok;
              }
            })];
}

function flatMap(p, fn) {
  return /* Parser */[(function (loc) {
              var err = runParser(p, loc);
              if (err.tag) {
                return err;
              } else {
                var match = err[0];
                var err$1 = runParser(Curry._1(fn, match[0]), match[1]);
                if (err$1.tag) {
                  return err$1;
                } else {
                  var match$1 = err$1[0];
                  return /* Ok */Block.__(0, [/* tuple */[
                              match$1[0],
                              match$1[1]
                            ]]);
                }
              }
            })];
}

function unit(a) {
  return /* Parser */[(function (loc) {
              return /* Ok */Block.__(0, [/* tuple */[
                          a,
                          loc
                        ]]);
            })];
}

function listOfN($$int, p) {
  return /* Parser */[(function (loc) {
              var _i = $$int;
              var p$1 = p;
              var _loc = loc;
              var _acc = /* array */[];
              while(true) {
                var acc = _acc;
                var loc$1 = _loc;
                var i = _i;
                var match = runParser(p$1, loc$1);
                if (match.tag) {
                  return /* Err */Block.__(1, [match[0]]);
                } else {
                  var match$1 = match[0];
                  var loc$2 = match$1[1];
                  var newAcc = $$Array.append(acc, /* array */[match$1[0]]);
                  if (i <= 0) {
                    return /* Ok */Block.__(0, [/* tuple */[
                                newAcc,
                                loc$2
                              ]]);
                  } else {
                    _acc = newAcc;
                    _loc = loc$2;
                    _i = i - 1 | 0;
                    continue ;
                  }
                }
              };
            })];
}

function many(p) {
  return /* Parser */[(function (loc) {
              var p$1 = p;
              var _loc = loc;
              var _acc = /* array */[];
              while(true) {
                var acc = _acc;
                var loc$1 = _loc;
                var match = runParser(p$1, loc$1);
                if (match.tag) {
                  return /* Ok */Block.__(0, [/* tuple */[
                              acc,
                              loc$1
                            ]]);
                } else {
                  var match$1 = match[0];
                  _acc = $$Array.append(acc, /* array */[match$1[0]]);
                  _loc = match$1[1];
                  continue ;
                }
              };
            })];
}

function many1(p) {
  return /* Parser */[(function (loc) {
              var err = runParser(many(p), loc);
              if (err.tag) {
                return err;
              } else {
                var match = err[0];
                var loc$1 = match[1];
                var v = match[0];
                if (v.length === 0) {
                  return /* Err */Block.__(1, [make(loc$1, "Expected at least one repetition for parser")]);
                } else {
                  return /* Ok */Block.__(0, [/* tuple */[
                              v,
                              loc$1
                            ]]);
                }
              }
            })];
}

function slice(p) {
  return /* Parser */[(function (loc) {
              var match = runParser(p, loc);
              if (match.tag) {
                return /* Err */Block.__(1, [match[0]]);
              } else {
                var newLoc = match[0][1];
                var charsConsumed = newLoc[/* offset */1] - loc[/* offset */1] | 0;
                var arg = loc[/* input */0];
                return /* Ok */Block.__(0, [/* tuple */[
                            (function (param) {
                                    return (function (param$1) {
                                        return arg.substr(param, param$1);
                                      });
                                  })(loc[/* offset */1])(charsConsumed),
                            newLoc
                          ]]);
              }
            })];
}

function regex(regexpr) {
  return /* Parser */[(function (loc) {
              var reg = new RegExp("^" + regexpr);
              if (reg.test(loc[/* input */0])) {
                var result = $$Array.map((function (x) {
                        return Belt_Option.getExn((x == null) ? undefined : Caml_option.some(x));
                      }), Belt_Option.getExn(Caml_option.null_to_opt(reg.exec(loc[/* input */0]))));
                var charsConsumed = Caml_array.caml_array_get(result, 0).length;
                var newLoc_000 = /* input */loc[/* input */0];
                var newLoc_001 = /* offset */loc[/* offset */1] + charsConsumed | 0;
                var newLoc = /* record */[
                  newLoc_000,
                  newLoc_001
                ];
                return /* Ok */Block.__(0, [/* tuple */[
                            result,
                            newLoc
                          ]]);
              } else {
                return /* Err */Block.__(1, [make(loc, "Expected: " + regexpr)]);
              }
            })];
}

var Parsers = /* module */[
  /* runParser */runParser,
  /* run */run,
  /* CannotGet */CannotGet,
  /* CannotGetError */CannotGetError,
  /* get_exn */get_exn,
  /* get_error */get_error,
  /* string */string,
  /* orElse */orElse,
  /* flatMap */flatMap,
  /* unit */unit,
  /* listOfN */listOfN,
  /* many */many,
  /* many1 */many1,
  /* slice */slice,
  /* regex */regex
];

exports.DerivedParsers = DerivedParsers;
exports.InfixOps = InfixOps;
exports.ParseError = ParseError;
exports.Parsers = Parsers;
/* No side effect */
