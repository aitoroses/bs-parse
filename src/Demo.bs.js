// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function explode(str) {
  var _i = str.length - 1 | 0;
  var _list = /* [] */0;
  while(true) {
    var list = _list;
    var i = _i;
    if (i < 0) {
      return list;
    } else {
      _list = /* :: */[
        Caml_string.get(str, i),
        list
      ];
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function char_to_string(param) {
  return $$String.make(1, param);
}

function char_list_to_string(list) {
  return List.fold_left((function (prim, prim$1) {
                return prim + prim$1;
              }), "", List.map(char_to_string, list));
}

function take(n, list) {
  if (list) {
    var match = n === 0;
    if (match) {
      return /* [] */0;
    } else {
      return /* :: */[
              list[0],
              take(n - 1 | 0, list[1])
            ];
    }
  } else {
    return /* [] */0;
  }
}

function DerivedParsers(P) {
  return (function (PS) {
      var Parsers = Curry._1(PS, P);
      var map = function (parser, fn) {
        return Curry._2(Parsers[/* flatMap */3], parser, (function (v) {
                      return Curry._1(Parsers[/* unit */4], Curry._1(fn, v));
                    }));
      };
      var map2 = function (parser1, parser2, fn) {
        return Curry._2(Parsers[/* flatMap */3], parser1, (function (v1) {
                      return map(parser2, (function (v2) {
                                    return Curry._2(fn, v1, v2);
                                  }));
                    }));
      };
      var product = function (parser1, parser2) {
        return map2(parser1, parser2, (function (v1, v2) {
                      return /* tuple */[
                              v1,
                              v2
                            ];
                    }));
      };
      var $$char = function (c) {
        return map(Curry._1(Parsers[/* string */1], char_to_string(c)), (function (s) {
                      return Caml_string.get(s, 0);
                    }));
      };
      return /* module */[
              /* Parsers */Parsers,
              /* map */map,
              /* map2 */map2,
              /* product */product,
              /* char */$$char
            ];
    });
}

function ParserInfix(P) {
  return (function (PS) {
      var Parsers = Curry._1(PS, P);
      var Parsers$1 = Curry._1(PS, P);
      var map = function (parser, fn) {
        return Curry._2(Parsers$1[/* flatMap */3], parser, (function (v) {
                      return Curry._1(Parsers$1[/* unit */4], Curry._1(fn, v));
                    }));
      };
      var map2 = function (parser1, parser2, fn) {
        return Curry._2(Parsers$1[/* flatMap */3], parser1, (function (v1) {
                      return map(parser2, (function (v2) {
                                    return Curry._2(fn, v1, v2);
                                  }));
                    }));
      };
      var product = function (parser1, parser2) {
        return map2(parser1, parser2, (function (v1, v2) {
                      return /* tuple */[
                              v1,
                              v2
                            ];
                    }));
      };
      var $$char = function (c) {
        return map(Curry._1(Parsers$1[/* string */1], char_to_string(c)), (function (s) {
                      return Caml_string.get(s, 0);
                    }));
      };
      var DP = /* module */[
        /* Parsers */Parsers$1,
        /* map */map,
        /* map2 */map2,
        /* product */product,
        /* char */$$char
      ];
      var $great$great$eq = Parsers[/* flatMap */3];
      var $less$pipe$great = Parsers[/* orElse */2];
      return /* module */[
              /* Parsers */Parsers,
              /* DP */DP,
              /* >>= */$great$great$eq,
              /* <$> */map,
              /* >> */product,
              /* <|> */$less$pipe$great
            ];
    });
}

function make(input, offset) {
  return /* record */[
          /* input */input,
          /* offset */offset
        ];
}

function line(loc) {
  var countBreaks = function (str) {
    return List.fold_left((function (acc, v) {
                  if (v === /* "\n" */10) {
                    return acc + 1 | 0;
                  } else {
                    return acc;
                  }
                }), 0, explode(str));
  };
  return countBreaks($$String.sub(loc[/* input */0], 0, loc[/* offset */1] + 1 | 0)) + 1 | 0;
}

function col(loc) {
  return $$Array.of_list(List.rev(explode($$String.sub(loc[/* input */0], 0, loc[/* offset */1] + 1 | 0)))).indexOf(/* "\n" */10);
}

var Location = /* module */[
  /* make */make,
  /* line */line,
  /* col */col
];

var $$JSON = /* module */[];

exports.explode = explode;
exports.char_to_string = char_to_string;
exports.char_list_to_string = char_list_to_string;
exports.take = take;
exports.DerivedParsers = DerivedParsers;
exports.ParserInfix = ParserInfix;
exports.Location = Location;
exports.$$JSON = $$JSON;
/* No side effect */
